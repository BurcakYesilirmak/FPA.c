#include <stdio.h>
#include <stdio.h>
#include<float.h>
#include<limits.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <string.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_odeiv2.h>
#define C  134217729 


typedef struct{
  char str[23], res[30], res1[30], rest[10], rest1[10];
  double value, xl, xh;
  int xx, m;
  long int num, num1, x1;
} numbers;

   void pairs(double *x_h, double *x_l) {
    numbers inp[6];
    char buffer[200];
     FILE *fp; ;
     int i, k, p, t, count;
     fp = fopen("denemeee.txt", "r+");
     if(!fp)
    {
        printf("Could not open file\n");
    } 
    // original numbers taken from the file
        count=1;
        
        while (fgets(buffer,200, fp)!= NULL) { 
         // printf("buffer=%s\n", buffer);
          sscanf(buffer, "%s", inp[0].str);
          sscanf(buffer, "%lf", &inp[0].value);
         // printf("string=%s value=%lf \n", inp[0].str, inp[0].value) ;  
          for(p=0;p<200; p++) {
            if(isspace(buffer[p])) { 
              sscanf(buffer+p+1, "%s", inp[count].str);
              sscanf(buffer+p, "%lf", &inp[count].value);
           // printf("string=%s value=%lf \n", inp[count].str, inp[count].value) ; 
              count++; }
           } }
          //printf("%d\n",count);
        for(i=0; i<count; i++) {
        inp[i].xx = sizeof(inp[i].str) ;         //size of number
        gcvt(inp[i].value,23,inp[i].res1); 
         // convert numbers to a string array    
       // printf("string1= %s string12= %s \n", inp[i].str, inp[i].res1);
        }
     // compare original and converted strings and find the starting different point 
      for(i=0; i<count; i++) {
      for(inp[i].m=0; inp[i].m<inp[i].xx ; inp[i].m++) {                 //find the similar finish point (m)
             if(inp[i].str[inp[i].m]!= inp[i].res1[inp[i].m])
                break;     
                }   // printf("point :\n%d\n", inp[i].m); 
   // printf("string1= %s string12= %.22s x= %d value=%c  value2=%c\n", inp[i].str, inp[i].res1,  inp[i].xx, inp[i].str[inp[i].m], inp[i].res1[inp[i].m]); 
       }
 

     for(i=0; i<count; i++) {
     for( t=inp[i].m, k=0; t<=inp[i].xx && k<inp[i].xx-inp[i].m ; t++, k++) {  
     inp[i].rest[k]= inp[i].str[t];
     inp[i].rest1[k]= inp[i].res1[t]; }
     //printf("string1= %s string2= %s \n", inp[i].rest, inp[i].rest1); 
      }

     // converts both strings to the long integer 
    for(i=0; i<count; i++) {
    sscanf(inp[i].rest, "%ld" , &inp[i].num);
    sscanf(inp[i].rest1, "%ld" , &inp[i].num1);    
    inp[i].x1 =(inp[i].num-inp[i].num1);          
   /* printf("string=%s value=%s \n", inp[i].rest, inp[i].rest1) ;  
    printf("num1=%ld num2=%ld \n", inp[i].num, inp[i].num1) ; 
    printf("x1=%ld \n\n", inp[i].x1) ; */
    }  

        for(i=0; i<count; i++) {
         // m=m-3; //different point without integer and comma 
       // if (inp[i].x1<0 && inp[i].value <0) { 
         inp[i].xl =-inp[i].x1*pow(10,-(inp[0].xx)+3); } // 2-> take into account integer and comma (lowest part)
      /*  else if (inp[i].x1<0 && inp[i].value >0)
        { inp[i].xl = -inp[i].x1*pow(10,-(inp[0].xx)+2); }
        else if (inp[i].x1>0 && inp[i].value <0)
        { inp[i].xl = inp[i].x1*pow(10,-(inp[0].xx)+3); }
        else ; 
        inp[i].xl = inp[i].x1*pow(10,-(inp[0].xx)+2); } */
             for(i=0; i<count; i++) {
        // printf("xh double:\n%.21lf\n",inp[i].value);
                 x_h[i] = inp[i].value;
       //printf("xh double:\n%.21lf\n", x_h[i]);
         //printf("xl double:\n %.21lf\n",inp[i].xl);
                 x_l[i] = inp[i].xl;
       //printf("xl double:\n %.21lf\n",x_l[i]);
       //printf("%s\n\n\n",inp[i].str);   
              }
             fclose(fp);
   }

void VeltkampSplit(double x, double *xh, double *xl) {        
double p = C * x;
double q = x - p;
*xh = p + q; 
*xl = x - *xh;
}

void F2Sum(double a, double b,double *xh, double *xl) {
double z;
*xh= a+b;
z = *xh-a;
*xl= b-z;
}

void TwoSum(double a, double b,double *xh, double *xl) {
double a1 ,b1 ,del_a ,del_b;
*xh= a+b;
a1= *xh-b;
b1= *xh-a1;
del_a = a-a1;
del_b = b-b1;
*xl = del_a+del_b;
}
//Pichat and Neumaierâ€™s summation algorithm
void Summation2(double xh1, double xl1, double xh2, double xl2,double *xh3, double *xl3 ){  
  double t,s,u,v,z;
  TwoSum(xh1, xh2, &t, &s);
  TwoSum(xl1, xl2, &u, &v);
  z= v+s+u; 
  //F2Sum(t, z, xh3, xl3);
  *xh3=t;
  *xl3=z; 
}   

// Dekker's & Polynomial Multiplication
void Mult(double xh1, double xl1, double xh2, double xl2,double *xh3, double *xl3) {
double xh_1, xl_1, xh_2, xl_2;
VeltkampSplit(xh1, &xh_1, &xl_1); 
VeltkampSplit(xh2, &xh_2, &xl_2); 
*xh3 =  xh1*xh2;
*xl3 =  xh_1*xh_2 - *xh3;
*xl3 +=  xh_1*xl_2;
*xl3 +=  xl_1*xh_2;
*xl3 +=  xl_1*xl_2+ xl1*xh2 + xh1*xl2;
return;
}

// with iteration
void Division(double xh1, double xl1, double xh2, double xl2,double *xh3, double *xl3){
double u1, u0, t, z;
t =xh1/xh2;
Mult(t, 0, xh2, 0,&u0,&u1); 
z = xh1- u0;
z -= u1;
z += xl1;
z -= *xh3 * xl2;
z /= xh2;  
F2Sum(t, z, xh3, xl3);
return;
} 

void scalar_product(double *xh3, double *xl3) {  // the square of the vector itself
    double xh[6], xl[6];
    pairs(xh, xl) ;
            double u0, u1, v0, v1, t0, t1 ,t2, t3;
      Mult(xh[0], xh[3], xh[0], xl[3], &u0, &u1); // xh^2 + xl^2
      Mult(xh[1], xl[1], xh[4], xl[4], &v0, &v1); // yh^2 + yl^2
      Mult(xh[2], xl[2], xh[5], xl[5], &t0, &t1); // zh^2 + zl^2
      Summation2(u0,u1,v0,v1,&t2,&t3);
      Summation2(t0,t1,t2,t3,xh3,xl3);
      }
    void scalar_product2(double xh[3], double xl[3],double *xh3, double *xl3) {  // the square of the vector itself
            double u0, u1, v0, v1, t0, t1 ,t2, t3;
      Mult(xh[0], xh[3], xh[0], xl[3], &u0, &u1); // xh^2 + xl^2
      Mult(xh[1], xl[1], xh[4], xl[4], &v0, &v1); // yh^2 + yl^2
      Mult(xh[2], xl[2], xh[5], xl[5], &t0, &t1); // zh^2 + zl^2
      Summation2(u0,u1,v0,v1,&t2,&t3);
      Summation2(t0,t1,t2,t3,xh3,xl3);
      }

   void unit_vector_pairwise(double *x_h, double *x_l) {
    double xh[6], xl[6];
    pairs(xh, xl) ;

        double F, dF, scalar_new, Z_new, Y_new, X_new ;
        double xh22, xl22, xh33, xl33, yhh, yll, zh33, zl33, dfhh, dfll;
        double xh44, xl44, xh55, xl55, xh66, xl66, xh555, xl555, xh333, xl333, xh444, xl444, xh222, xl222;
        int i,count;

    //finding maximum absolute value of the vector
    double k[]={ xh[0], xh[1], xh[2] };  
    double max =fabs(k[1]);
    for( i=0; i<3; i++) {
    if(fabs(k[i])>max) 
    max =fabs(k[i]);
    }
    //initilial value of alpha with double
    double alpha = 1/max;
    double eps=1e-15;
    count =0;
    do {
        count ++ ;
        //for double 
       X_new= xh[0]*alpha;
       Y_new= xh[1]*alpha;
       Z_new= xh[2]*alpha;
       scalar_new = X_new*X_new + Y_new*Y_new + Z_new*Z_new ;
       F = scalar_new-1 ;
       dF =  2/alpha*scalar_new ;
       alpha -= F/dF;} 
     while (scalar_new - 1 >= eps);    // get approximate good alpha 

         //  calculating alpha biggest part as pairs
        Mult(alpha, 0.0, xh[0], xl[0], &xh44, &xl44);
        Mult(alpha, 0.0, xh[1], xl[1], &xh55, &xl55);
        Mult(alpha, 0.0, xh[2], xl[2], &xh66, &xl66); 
       double xx[3]= {xh44, xh55, xh66};
       double yy[3]= {xl44, xl55, xl66};
       scalar_product2(xx, yy, &xh33, &xl33); 

       // alpha = alpha - (alpha*0.5) * (sc-1)/sc  
       Mult(alpha, 0.0, 0.5, 0.0, &yhh, &yll);      // alpha*0.5                     
       Division(xh33-1, xl33, xh33, xl33, &dfhh, &dfll);        // (sc-1)/sc
       Mult(dfhh, dfll, yhh, yll, &xh555, &xl555);       
       Mult(xh555, xl555, -1, 0.0, &xh22, &xl22);
       Summation2(xh22, xl22, alpha, 0.0, &zh33, &zl33); 

     // xh[]*alpha
    Mult(xh[0], 0.0, zh33, zl33, &xh444, &xl444);
    Mult(xh[1], 0.0, zh33, zl33, &xh222, &xl222); 
    Mult(xh[2], 0.0, zh33, zl33, &xh333, &xl333);   
    x_h[0] =  xh444;   // *(x_h+0)=x_h[0]
    x_h[1] =  xh222;
    x_h[2] =  xh333; 
    x_l[0] =  xl444;
    x_l[1] =  xl222;
    x_l[2] =  xl333; 
   } 

int func (double t,const double y[], double f[], 
        void *params)
{
  (void)(t); 
  double mu = *(double *)params;
  double unith[3], unitl[3], xh, xl, xh1, xl1, xh2, xl2, xh3, xl3, xh4, xl4, o;


  //y[0]=x , y[1]=y , y[2]=z  
    f[0] = y[6];  //Vx_h
    f[1] = y[7];  //Vy_h
    f[2] = y[8];  //Vz_h

    f[3] = y[9];  //Vx_l
    f[4] = y[10];  //Vy_l
    f[5] = y[11];  //Vz_l

      // f[3] = -mu/k* I   ,      f[4] = -mu/k* J ,     f[5] =  -mu/k* K

      o = 0.0;
      unit_vector_pairwise(unith, unitl);
      scalar_product(&xh, &xl); //k = y[0]*y[0]+y[1]*y[1]+y[2]*y[2]

      // (-mu/k)
       Division(mu, o, xh, xl, &xh2, &xl2); 
       Mult(xh2, xl2, -1, o, &xh1, &xl1);     
       
       // (-mu/k)*unit for each component , where k = X^2+Y^2+Z^2
       Mult(xh1, xl1, unith[0], unitl[0], &xh2, &xl2);      
       Mult(xh1, xl1, unith[1], unitl[1], &xh3, &xl3);     
       Mult(xh1, xl1, unith[2], unitl[2], &xh4, &xl4);   

       // assign corresponding system                              
       f[6]=  xh2;
       f[7]=  xh3;
       f[8]=  xh4;

       f[9]=  xl2;
       f[10]= xl3;
       f[11]= xl4;
  return GSL_SUCCESS;
}
int jac (double t,const double y[], double *dfdy,
     double dfdt[], void *params)
{
  (void)(t); 
  double mu = *(double *)params;
  double unith[3], unitl[3], xh, xl, xhh, xll, xh11, xl11, xhh1, xll1;
  double xh1, xl1,  xh2, xl2, xh3, xl3, xhA, xhB, xhC, xlA, xlB, xlC, y1, y2, y3, y4, y5, y6;
  double xh2x, xl2x , xh2y, xl2y, xh2z, xl2z, xhxy, xlxy, xhxz, xlxz, xhyz, xlyz, xh_xy, xl_xy, xh_xz, xl_xz, xh_yz, xl_yz ;
  double xh_A, xl_A, xh_B, xl_B, xh_C, xl_C, xh_AA, xl_AA, xh_BB, xl_BB, xh_CC, xl_CC, xh_i, xl_i, xh_j, xl_j, xh_k, xl_k, xh_muk2, xl_muk2;
  double xh_xj, xl_xj, xh_xk, xl_xk, xh_yi, xl_yi, xh_yk, xl_yk, xh_zi, xl_zi, xh_zj, xl_zj, xh_X, xl_X, xh_Y, xl_Y, xh_Z, xl_Z ;
  int i, k ;
  double p, o;

  gsl_matrix_view dfdy_mat
    = gsl_matrix_view_array (dfdy, 12, 12);

   // mu*(2*y[0]*y[0]-(y[1]*y[1]+y[2]*y[2]))/(r*k))  =    [ 2*X^2-(Y^2-Z^2)]* mu / X*K^2 * I

    // seperate position vectors from buffer line and calculate unit vector
    unit_vector_pairwise(unith, unitl);

    // calculate first scalar product of position vector 
    // then find corresponding expression for function
     scalar_product( &xhh, &xll); //k = yh[0]*yh[0]+yh[1]*yh[1]+yh[2]*yh[2]
     xhh1= xhh;
     xll1= xll;
     Mult(xhh, xll, xhh1, xll1, &xh, &xl); // r= k*sqrt(k)   and r*k= k^2*sqrt(k),   here is k^2's pairs

        o = 0.0;
     Division(mu, o, xh, xl, &xh11, &xl11); // mu/k^2

       y1 = y[0]; // xh
       y2 = y[1]; // yh
       y3 = y[2]; // zh

       y4 = y[3]; // xl
       y5 = y[4]; // yl
       y6 = y[5]; // zl
       
        // calculate mu*(2*y[0]*y[0]-(y[1]*y[1]+y[2]*y[2]))/(k^2*sqrt(k)) where k = X^2+Y^2+Z^2
     Mult(y[0], y[3], y1, y4, &xh1, &xl1); //X^2
     Mult(y[1], y[4], y2, y5, &xh2, &xl2); //Y^2
     Mult(y[2], y[5], y3, y6, &xh3, &xl3); //Z^2

     Mult(xh1, xl1, 2.0, o, &xh2x, &xl2x);    // 2*X^2
     Mult(xh2, xl2, 2.0, o, &xh2y, &xl2y);    // 2*Y^2
     Mult(xh3, xl3, 2.0, o, &xh2z, &xl2z);    // 2*Z^2

     Summation2(xh1, xl1, xh2, xl2, &xhxy, &xlxy); // X^2+Y^2 
     Summation2(xh1, xl1, xh3, xl3, &xhxz, &xlxz); // X^2+Z^2 
     Summation2(xh3, xl3, xh2, xl2, &xhyz, &xlyz); // Y^2+Z^2 

     Mult(xhxy, xlxy, -1, o, &xh_xy, &xl_xy);        // LOOOOOOOKK necessary or not?
     Mult(xhxz, xlxz, -1, o, &xh_xz, &xl_xz);         
     Mult(xhyz, xlyz, -1, o, &xh_yz, &xl_yz);         

     Summation2(xh2x, xl2x, xh_yz, xl_yz, &xh_A, &xl_A);   //2*X^2-(Y^2+Z^2)
     Summation2(xh2y, xl2y, xh_xz, xl_xz, &xh_B, &xl_B);   //2*Y^2-(X^2+Z^2)
     Summation2(xh2z, xl2z, xh_xy, xl_xy, &xh_C, &xl_C);   //2*Z^2-(X^2+Y^2)

     Mult(xh_A, xl_A, xh11, xl11, &xhA, &xlA);    // 2*X^2-(Y^2+Z^2)*(mu/k^2)
     Mult(xh_B, xl_B, xh11, xl11, &xhB, &xlB);    // 2*Y^2-(X^2+Z^2)*(mu/k^2)
     Mult(xh_C, xl_C, xh11, xl11, &xhC, &xlC);    // 2*Z^2-(X^2+Y^2)*(mu/k^2)
     
     Division(xh_A, xl_A, y1, y4, &xh_AA, &xl_AA);    // 2*X^2-(Y^2+Z^2)*(mu/k^2) = A
     Division(xh_B, xl_B, y2, y5,  &xh_BB, &xl_BB);    // 2*Y^2-(X^2+Z^2)*(mu/k^2) = B
     Division(xh_C, xl_C, y3, y6, &xh_CC, &xl_CC);    // 2*Z^2-(X^2+Y^2)*(mu/k^2) = C

     Mult(xh_AA, xl_AA, unith[0], unitl[0], &xh_i, &xl_i);    // A*i 
     Mult(xh_BB, xl_BB, unith[1], unitl[1], &xh_j, &xl_j);    // B*j
     Mult(xh_CC, xl_CC, unith[2], unitl[2], &xh_k, &xl_k);    // C*k 
    

    // calculate 3*mu*y[0]*y[1]/(k^2*sqrt(k) where k = X^2+Y^2+Z^2
     Mult(xh11, xl11, 3.0, o, &xh_muk2, &xl_muk2);    //  3*mu/k2 
     Mult(xh_muk2, xl_muk2, y[0], y[3], &xh_X, &xl_X);    // 3*mu/k2* X
     Mult(xh_muk2, xl_muk2, y[1], y[4], &xh_Y, &xl_Y);    // 3*mu/k2* Y
     Mult(xh_muk2, xl_muk2, y[2], y[5], &xh_Z, &xl_Z);    // 3*mu/k2* Z

    
     // for I
     Mult(xh_Y, xl_Y, unith[0], unitl[0], &xh_yi, &xl_yi);    // Y*i
     Mult(xh_Z, xl_Z, unith[0], unitl[0], &xh_zi, &xl_zi);    // Z*i
     // for J
     Mult(xh_X, xl_X, unith[1], unitl[1], &xh_xj, &xl_xj);    // X*j
     Mult(xh_Z, xl_Z, unith[1], unitl[1], &xh_zj, &xl_zj);    // Z*j
     // for K
     Mult(xh_X, xl_X, unith[2], unitl[2], &xh_xk, &xl_xk);    // X*k
     Mult(xh_Y, xl_Y, unith[2], unitl[2], &xh_yk, &xl_yk);    // Y*k
    
  // fill the Jacobian matrix 
  gsl_matrix * m = &dfdy_mat.matrix;
     
     
     // Part 1
      for (i=0 ; i<=11; i++) {
      for(k=0; k<=11; k++){
      if ( k - i == 6 ) {
         p=1.0;  }
      else if ( k - i != 3 )
         p=0.0; 
      gsl_matrix_set (m, i, k, p);
      } }

      //Part 2
         p=0.0;
      for (i=6 ; i<=11; i++) {
      for( k=3; k<=11; k++){
     gsl_matrix_set (m, i, k, p);
      } }

  gsl_matrix_set (m, 6, 0, xh_i); //it is coming pairs?
  gsl_matrix_set (m, 6, 1, xh_yi);
  gsl_matrix_set (m, 6, 2, xh_zi);

  gsl_matrix_set (m, 7, 0, xh_j);
  gsl_matrix_set (m, 7, 1, xh_xj);
  gsl_matrix_set (m, 7, 2, xh_zj);

  gsl_matrix_set (m, 8, 0, xh_k);
  gsl_matrix_set (m, 8, 1, xh_xk);
  gsl_matrix_set (m, 8, 2, xh_yk);

  gsl_matrix_set (m, 9, 0, xl_i); //it is coming pairs?
  gsl_matrix_set (m, 9, 1, xl_yi);
  gsl_matrix_set (m, 9, 2, xl_zi);

  gsl_matrix_set (m, 10, 0, xl_j);
  gsl_matrix_set (m, 10, 1, xl_xj);
  gsl_matrix_set (m, 10, 2, xl_zj);

  gsl_matrix_set (m, 11, 0, xl_k);
  gsl_matrix_set (m, 11, 1, xl_xk);
  gsl_matrix_set (m, 11, 2, xl_yk);

// set explicit t dependence of f[i] 
     for (i=0 ; i<=12; i++) {
        dfdt[0] = 0.0; } 
  return GSL_SUCCESS;
}

int
main (void)
{
   double k3=0.01720209895, mu ;
    mu= k3*k3; 
    // xh[6] = { Xh Yh Zh Vxh Vyh Vzh } and xl[6]= { Xl Yl Zl Vxl Vyl Vzl  }
    double xh[6], xl[6];
    pairs(xh, xl) ;
  gsl_odeiv2_system sys = {func, jac, 12, &mu};
// time step parameters 
  double t = 0.0, t_step=1, T=10000;
// Select explicit method
  const gsl_odeiv2_step_type * st = gsl_odeiv2_step_msadams;
  //set errors and create the driver object
  double abserr = 1e-10;
  double relerr = 0.0;
  double a, b, c, d, e, f, aa, bb, cc, dd, ee, ff;

   a= xh[0] ;   // *(x_h+0)=x_h[0]
   b= xh[1] ;
   c= xh[2] ; 
   d= xl[0] ;
   e= xl[1] ;
   f= xl[2] ; 
   aa= xh[3] ;   // *(x_h+0)=x_h[0]
   bb= xh[4] ;
   cc= xh[5] ; 
   dd =xl[3] ;
   ee= xl[4] ;
   ff= xl[5] ; 


  gsl_odeiv2_driver* driver= 
    gsl_odeiv2_driver_alloc_y_new(&sys, st, t_step, abserr, relerr);
  // double y[12] = { xh[0], xh[1], xh[2],  xl[0], xl[1], xl[2], xh[3], xh[4], xh[5], xl[3], xl[4], xl[5]};
  double y[12] = {  a, b, c, d, e, f, aa, bb, cc, dd, ee, ff };
         FILE *kk, *pp;
        kk=fopen("TEST_Rh_Rl.txt","w");
        pp=fopen("TEST_Vh_Vl.txt","w");
                  while (t <= T) {
      gsl_odeiv2_driver_apply (driver, &t, t+t_step, y); 
                // Xh Yh Zh Xl Yl Zl Vxh Vyh Vzh Vxl Vyl Vzl  
    fprintf(kk,"%f  %.15le %.15le %.15le %.15le %.15le %.15le\n", t, y[0], y[1],  y[2], y[3],  y[4], y[5]);
    fprintf(pp,"%f %.15le %.15le %.15le %.15le %.15le %.15le\n", t, y[6], y[7],  y[8], y[9],  y[10], y[11]);
            }
  gsl_odeiv2_driver_free (driver);
                      fclose(kk);
                       fclose(pp);
  return 0;
  //gcc -Wall -I/usr/local/Cellar/gsl/2.6/include gsl33.c  -L/usr/local/Cellar/gsl/2.6/lib -lgsl -lgslcblas -lm -o gsl33
}










