    /* JPL/HORIZONS 2 Pallas (A802 FA)     
     Coordinate Origin :	Sun (body center) [500@10]
     Time Span [change] : 	Start=2018-06-05, Stop=2019-06-05, Step=1 d */

#include <stdio.h>
#include <stdio.h>
#include<float.h>
#include<limits.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <string.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_odeiv2.h>
#define C  134217729 


 typedef struct{
  char str[22], res[30], res1[30], rest[10], rest1[10];
  double value, xl, xh;
  int xx, m, countt, counttt;
  long int num, num1, x1, num2, num3;
} numbers;

 typedef struct{
  double mu_h;
  double mu_l;
} data;

void pairs(double *x_h, double *x_l) {
    numbers inp[6];
    char buffer[150];
    FILE *fp; ;
      int i, k, p, t, count, pp;
      fp = fopen("SPLIT.txt", "r");
      if(!fp)
        {
        printf("Could not open file\n");
        } 
        // original numbers taken from the file
        count=0; 
    while (fgets(buffer,150, fp)!= NULL) { 
        //    printf("buffer=%s\n", buffer);
    for(pp=0; pp<150 ; pp++)  //looking for end of line 
        if(buffer[pp]=='\0')
            break;
          sscanf(buffer, "%s", inp[count].str);
          sscanf(buffer, "%lf", &inp[count].value);
          //printf("pp=%d count=%d string=%s value=%lf \n", pp, count, inp[count].str, inp[count].value) ; 
          count++;
    for( p=0; p<pp-1; p++) {            
        if(isspace(buffer[p])){           //looking for space    
            sscanf(buffer+p+1, "%s", inp[count].str);
            sscanf(buffer+p+1, "%lf", &inp[count].value);
       //   printf("count=%d string=%s value=%lf \n", count, inp[count].str, inp[count].value) ; 
              count++;
              } }
        } 
        inp[3].value= inp[3].value/100;
        inp[4].value= inp[4].value/1000;
        inp[5].value= inp[5].value/1000;

     //  printf("count = %d \n", count);     

      for(i=0; i<count; i++) {
        inp[i].xx = sizeof(inp[i].str) ;         //size of number
        gcvt(inp[i].value,22,inp[i].res1);       // convert numbers to a string array     -ise 1 eksik
       //printf("size : %d \n\n", inp[i].xx); 
       }
       // compare original and converted strings and find the starting different point 
       for(i=0; i<count; i++) {
         for(inp[i].m=0; inp[i].m<inp[i].xx ; inp[i].m++) {                 //find the similar finish point (m)
            if(inp[i].str[inp[i].m]!= inp[i].res1[inp[i].m])
                break;     
                } 
      } 
 
    for(i=0; i<count; i++) {
     for( t=inp[i].m, k=0; t<=inp[i].xx && k<inp[i].xx-inp[i].m ; t++, k++) {  
        inp[i].rest[k]= inp[i].str[t];
        inp[i].rest1[k]= inp[i].res1[t];  }   
     }



     // converts both strings to the long integer 
    for(i=0; i<count; i++) {
        sscanf(inp[i].rest, "%ld" , &inp[i].num1);
        sscanf(inp[i].rest1, "%ld" , &inp[i].num2);   
        }

    for(i=0; i<count; i++) {
        inp[i].num  = inp[i].num1 ;
        inp[i].num3  = inp[i].num2 ;
        inp[i].countt=0;
        inp[i].counttt=0;
    while (inp[i].num != 0) {
        inp[i].num /= 10; 
        ++inp[i].countt;
        }
    while (inp[i].num3 != 0) {
        inp[i].num3 /= 10; 
        ++inp[i].counttt; }         
            if(inp[i].countt != inp[i].counttt){
              inp[i].num1 *= 10;  } 
            else ; 
              inp[i].num1 *= 1;     
              inp[i].x1 = inp[i].num1-inp[i].num2;  
                      }
    inp[0].xl =-inp[0].x1*pow(10,-(inp[0].xx)+2); 
    inp[1].xl =inp[1].x1*pow(10,-(inp[1].xx)+2); 
    inp[2].xl =-inp[2].x1*pow(10,-(inp[2].xx)+3); 
    inp[3].xl =-inp[3].x1*pow(10,-(inp[3].xx)+1); 
    inp[4].xl =-inp[4].x1*pow(10,-(inp[4].xx)); 
    inp[5].xl = inp[5].x1*pow(10,-(inp[5].xx)-1); //} // 2-> take into account integer and comma (lowest part)
        x_h[0] = inp[0].value/10;  // X
        x_h[1] = inp[1].value;     // Y
        x_h[2] = inp[2].value;     // Z
        x_h[3] = inp[3].value;     // Vx
        x_h[4] = inp[4].value;     // Vy
        x_h[5] = inp[5].value;     // Vz
    for(i=0; i<count; i++) {
        x_l[i] = inp[i].xl; }
     /* printf("xh double:\n%.21lf\n", x_h[i]);
        printf("xl double:\n%.21lf\n",x_l[i]);
        printf(" %s\n\n\n",inp[i].str);  */
    fclose(fp);
    }  
      

    void VeltkampSplit(double x, double *xh, double *xl) {        
    double p = C * x;
    double q = x - p;
    *xh = p + q; 
    *xl = x - *xh;
    }

    void F2Sum(double a, double b,double *xh, double *xl) {
    double z;
    *xh= a+b;
    z = *xh-a;
    *xl= b-z;
    }

    void TwoSum(double a, double b,double *xh, double *xl) {
    double a1 ,b1 ,del_a ,del_b;
    *xh= a+b;
    a1= *xh-b;
    b1= *xh-a1;
    del_a = a-a1;
    del_b = b-b1;
    *xl = del_a+del_b;
    }

    //Pichat and Neumaierâ€™s summation algorithm
    void Summation2(double xh1, double xl1, double xh2, double xl2,double *xh3, double *xl3 ){  
    double t,s,u,v,z;
    TwoSum(xh1, xh2, &t, &s);
    TwoSum(xl1, xl2, &u, &v);
    z= v+s+u; 
    //F2Sum(t, z, xh3, xl3);
    *xh3=t;
    *xl3=z; 
    }   

    // Dekker's & Polynomial Multiplication
    void Mult(double xh1, double xl1, double xh2, double xl2,double *xh3, double *xl3) {
    double xh_1, xl_1, xh_2, xl_2;
    VeltkampSplit(xh1, &xh_1, &xl_1); 
    VeltkampSplit(xh2, &xh_2, &xl_2); 
    *xh3 =  xh1*xh2;
    *xl3 =  xh_1*xh_2 - *xh3;
    *xl3 +=  xh_1*xl_2;
    *xl3 +=  xl_1*xh_2;
    *xl3 +=  xl_1*xl_2+ xl1*xh2 + xh1*xl2;
    return;
    }

    // with iteration
    void Division(double xh1, double xl1, double xh2, double xl2,double *xh3, double *xl3){
    double u1, u0, t, z;
    t =xh1/xh2;
    Mult(t, 0, xh2, 0,&u0,&u1); 
    z = xh1- u0;
    z -= u1;
    z += xl1;
    z -= *xh3 * xl2;
    z /= xh2;  
    F2Sum(t, z, xh3, xl3);
    return;
} 

    void scalar_product2(double xh[3], double xl[3],double *xh3, double *xl3) {         // the square of the vector's itself
      double u0, u1, v0, v1, t0, t1 ,t2, t3;
      Mult(xh[0], xl[0], xh[0], xl[0], &u0, &u1); // xh^2 and xl^2
      Mult(xh[1], xl[1], xh[1], xl[1], &v0, &v1); // yh^2 and yl^2
      Mult(xh[2], xl[2], xh[2], xl[2], &t0, &t1); // zh^2 and zl^2
      Summation2(u0,u1,v0,v1,&t2,&t3);
      Summation2(t0,t1,t2,t3,xh3,xl3);
      }

    void unit_vector_pairwise(double xh[3], double xl[3], double *x_h, double *x_l) {

        double F, dF, scalar_new, Z_new, Y_new, X_new ;
        double xh22, xl22, xh33, xl33, yhh, yll, zh33, zl33, dfhh, dfll;
        double xh44, xl44, xh55, xl55, xh66, xl66, xh555, xl555, xh333, xl333, xh444, xl444, xh222, xl222;
        int i,count;

    //finding maximum absolute value of the vector
    double k[]={ xh[0], xh[1], xh[2] };  
    double max =fabs(k[1]);
    for( i=0; i<3; i++) {
    if(fabs(k[i])>max) 
    max =fabs(k[i]);
    }
    //initilial value of alpha with double
    double alpha = 1/max;
    double eps=1e-15;
    count =0;
    do {
        count ++ ;
        //for double 
       X_new= xh[0]*alpha;
       Y_new= xh[1]*alpha;
       Z_new= xh[2]*alpha;
       scalar_new = X_new*X_new + Y_new*Y_new + Z_new*Z_new ;
       F = scalar_new-1 ;
       dF =  2/alpha*scalar_new ;
       alpha -= F/dF;} 
    while (scalar_new - 1 >= eps);    // get approximate good alpha 

         //  calculating alpha biggest part as pairs
        Mult(alpha, 0.0, xh[0], xl[0], &xh44, &xl44);
        Mult(alpha, 0.0, xh[1], xl[1], &xh55, &xl55);
        Mult(alpha, 0.0, xh[2], xl[2], &xh66, &xl66); 
       double xx[3]= {xh44, xh55, xh66};
       double yy[3]= {xl44, xl55, xl66};
       scalar_product2(xx, yy, &xh33, &xl33); 

       // alpha = alpha - (alpha*0.5) * (sc-1)/sc  
       Mult(alpha, 0.0, 0.5, 0.0, &yhh, &yll);      // alpha*0.5                     
       Division(xh33-1, xl33, xh33, xl33, &dfhh, &dfll);        // (sc-1)/sc
       Mult(dfhh, dfll, yhh, yll, &xh555, &xl555);       
       Mult(xh555, xl555, -1, 0.0, &xh22, &xl22);
       Summation2(xh22, xl22, alpha, 0.0, &zh33, &zl33); 

     // xh[]*alpha
    Mult(xh[0], 0.0, zh33, zl33, &xh444, &xl444);
    Mult(xh[1], 0.0, zh33, zl33, &xh222, &xl222); 
    Mult(xh[2], 0.0, zh33, zl33, &xh333, &xl333);   
    x_h[0] =  xh444;   // *(x_h+0)=x_h[0]
    x_h[1] =  xh222;
    x_h[2] =  xh333; 
    x_l[0] =  xl444;
    x_l[1] =  xl222;
    x_l[2] =  xl333; 
   } 

int func (double t,const double y[], double f[], void *params)
{
  (void)(t); 
  data *par = (data *)params;
 // double mu_h =  0.017202098950000001276;
 // double mu_l = -0.000000000000000001276;

  double xh, yh, zh, xl, yl, zl, xx, yy, o;
  double xh2, xl2, xh3, xl3, xh4, xl4;
  double unith[3], unitl[3], sc_h, sc_l;

  //y[0]=x , y[1]=y , y[2]=z 

    f[0] = y[6];  // Vx_h       // I did not take into account lowest part of velocity vector
    f[1] = y[7];  // Vy_h
    f[2] = y[8];  // Vz_h   

    xh = y[0]; // pairs of biggest part of position vector
    yh = y[1];
    zh = y[2];

    xl = y[3]; // pairs of lowest of for position vector
    yl = y[4];
    zl = y[5]; 


    // f[3] = -mu/k* I   ,      f[4] = -mu/k* J ,     f[5] =  -mu/k* K
    o = 0.0;
   double pos_h[3] = { xh, yh, zh};
   double pos_l[3] = { xl, yl, zl};

       unit_vector_pairwise(pos_h, pos_l, unith, unitl); //for biggest part
       //k = y[0]*y[0]+y[1]*y[1]+y[2]*y[2] 
       scalar_product2(pos_h, pos_l, &sc_h, &sc_l);  
 
       //  FOR BIGGEST PART
       Division(par->mu_h, par->mu_l, sc_h, sc_l, &xx, &yy); //  -mu / (Xh^2+Yh^2+Zh^2)

       // (-mu/k)*UNIT for each component , where k = (Xh+Xl)^2+(Yh+Yl)^2+(Zh+Zl)^2
       Mult(-xx, -yy, unith[0], unitl[0], &xh2, &xl2);      
       Mult(-xx, -yy, unith[1], unitl[1], &xh3, &xl3);     
       Mult(-xx, -yy, unith[2], unitl[2], &xh4, &xl4); 


 /*     printf("%.16le\n", xh2);
                  printf("%.16le\n", xh3);
                           printf("%.16le\n", xh4);
           printf("%.16le\n", xl2);
                  printf("%.16le\n", xl3);
                           printf("%.16le\n", xl4);                        
    exit(1);    */

       // assign corresponding system   

       // -mu*R/ |R|^(3/2)            should I sum them with accurate calculation OR NOT?               
       f[6]=  xh2;   // h_x
       f[7]=  xh3;   // h_y
       f[8]=  xh4;   // h_z
    
  return GSL_SUCCESS;
}

int jac (double t,const double y[], double *dfdy,
     double dfdt[], void *params)
{
 // (void)(t); 
  data *par = (data *)params;
  //double mu_h = 0.017202098950000001276;
  //double mu_l =-0.000000000000000001276;
  double x_h, y_h, z_h, x_l, y_l, z_l;
  double unith[3], unitl[3], sc_h, sc_l;
  double xh, xl, XH, YH, ZH, XL, YL, ZL;
  double xh11, xl11, xh1, xl1,  xh2, xl2, xh3, xl3;
  double xh2x, xl2x , xh2y, xl2y, xh2z, xl2z; 
  double xh_A, xl_A, xh_B, xl_B, xh_C, xl_C;
  double xhA, xhB, xhC, xlA, xlB, xlC;
  double k_xH, k_xh, k_yH, k_yh, k_zH, k_zh, xH_muk2, xL_muk2; 
  double xh_X, xl_X, xh_Y, xl_Y, xh_Z, xl_Z;
  double xh_I, xl_I, xh_J, xl_J, xh_K, xl_K;
  double xh_xj, xl_xj, xh_xk, xl_xk, xh_yi, xl_yi, xh_yk, xl_yk, xh_zi, xl_zi, xh_zj, xl_zj;
  double p,o;
  int i,k;

   // mu*(2*y[0]*y[0]-(y[1]*y[1]+y[2]*y[2]))/(r*k))  =    [ 2*X^2-(Y^2-Z^2)]* mu / X*K^2 * I

    x_h = y[0]; // pairs of biggest part of position vector
    y_h = y[1];
    z_h = y[2];

    x_l = y[3]; // pairs of lowest of for position vector
    y_l = y[4];
    z_l = y[5]; 

    // f[3] = -mu/k* I   ,      f[4] = -mu/k* J ,     f[5] =  -mu/k* K
    o = 0.0;
    double pos_h[3] = { x_h, y_h, z_h};
    double pos_l[3] = { x_l, y_l, z_l};

       unit_vector_pairwise(pos_h, pos_l, unith, unitl); //for biggest part
       //k = y[0]*y[0]+y[1]*y[1]+y[2]*y[2] 
       scalar_product2(pos_h, pos_l, &sc_h, &sc_l); 


    // calculate first scalar product of position vector 
    // then find corresponding expression for function

     // r= k*sqrt(k)   we need to find k^2 for both where k = X^2+Y^2+Z^2
     Mult(sc_h, sc_l, sc_h, sc_l, &xh, &xl); 

     // for mu/k^2*Rh
     Mult(xh, xl, x_h, x_l, &k_xH, &k_xh);  // k^2*(Xh+Xl)
     Mult(xh, xl, y_h, y_l, &k_yH, &k_yh);  // k^2*(Yh+Yl)
     Mult(xh, xl, z_h, z_l, &k_zH, &k_zh);  // k^2*(Zh+Zl)

     Division(par->mu_h, par->mu_l, k_xH, k_xh, &XH, &XL); // mu/(k^2*(Xh+Xl))
     Division(par->mu_h, par->mu_l,  k_yH, k_yh, &YH, &YL); // mu/(k^2*(Yh+Yl))
     Division(par->mu_h, par->mu_l, k_zH, k_zh, &ZH, &ZL); // mu/(k^2*(Zh+Zl))

     // mu/k^2 for both pairs
     Division(par->mu_h, par->mu_l, xh, xl, &xh11, &xl11);  
     Mult(xh11, xl11, 3.0, o, &xH_muk2, &xL_muk2);    //  3*mu/k2  for biggest 

    // CALCULATE mu*(2*y[0]*y[0]-(y[1]*y[1]+y[2]*y[2]))/(k^2*sqrt(k)) where k = X^2+Y^2+Z^2

    // FOR BIGGEST PART
     Mult(x_h, x_l, x_h, x_l, &xh1, &xl1); //X^2
     Mult(y_h, y_l, y_h, y_l, &xh2, &xl2); //Y^2
     Mult(z_h, z_l, z_h, z_l, &xh3, &xl3); //Z^2

     Mult(xh1, xl1, 3.0, o, &xh2x, &xl2x);    // 3*(Xh+Xl)^2
     Mult(xh2, xl2, 3.0, o, &xh2y, &xl2y);    // 3*(Yh+Yl)^2
     Mult(xh3, xl3, 3.0, o, &xh2z, &xl2z);    // 3*(Zh+Zl)^2

     Summation2(xh2x, xl2x, -xh, -xl, &xh_A, &xl_A);   //2*(Xh+Xl)^2-k^2
     Summation2(xh2y, xl2y, -xh, -xl, &xh_B, &xl_B);   //2*(Yh+Yl)^2-k^2
     Summation2(xh2z, xl2z, -xh, -xl, &xh_C, &xl_C);   //2*(Zh+Zl)^2-k^2

     Mult(xh_A, xl_A, XH, XL, &xhA, &xlA);    // 2*X^2-k^2*(mu/k^2*X) = A
     Mult(xh_B, xl_B, YH, YL, &xhB, &xlB);    // 2*Y^2-k^2*(mu/k^2*Y) = B
     Mult(xh_C, xl_C, ZH, ZL, &xhC, &xlC);    // 2*Z^2-k^2*(mu/k^2*Z) = C


     Mult(xhA, xlA, unith[0], unitl[0], &xh_I, &xl_I);    // A*I 
     Mult(xhB, xlB, unith[1], unitl[1], &xh_J, &xl_J);    // B*J
     Mult(xhC, xlC, unith[2], unitl[2], &xh_K, &xl_K);    // C*K 

    // calculate 3*mu*y[0]*y[1]/(k^2*sqrt(k) where k = X^2+Y^2+Z^2
    
     Mult(xH_muk2, xL_muk2, x_h, x_l, &xh_X, &xl_X);    // 3*mu/k2* Xh
     Mult(xH_muk2, xL_muk2, y_h, y_l, &xh_Y, &xl_Y);    // 3*mu/k2* Yh
     Mult(xH_muk2, xL_muk2, z_h, z_l, &xh_Z, &xl_Z);    // 3*mu/k2* Zh
    
     // for I
     Mult(xh_Y, xl_Y, unith[0], unitl[0], &xh_yi, &xl_yi);    // Yh*I
     Mult(xh_Z, xl_Z, unith[0], unitl[0], &xh_zi, &xl_zi);    // Zh*I

     // for J
     Mult(xh_X, xl_X, unith[1], unitl[1], &xh_xj, &xl_xj);    // Xh*J
     Mult(xh_Z, xl_Z, unith[1], unitl[1], &xh_zj, &xl_zj);    // Zh*J

     // for K
     Mult(xh_X, xl_X, unith[2], unitl[2], &xh_xk, &xl_xk);    // Xh*K
     Mult(xh_Y, xl_Y, unith[2], unitl[2], &xh_yk, &xl_yk);    // Yh*K

    gsl_matrix_view dfdy_mat
        = gsl_matrix_view_array (dfdy, 12, 12);
    
  // fill the Jacobian matrix 
  gsl_matrix * m = &dfdy_mat.matrix;
     // Part 1 for zeros
    for (i=0 ; i<=2; i++) {
      for(k=0; k<=2; k++){
         p=0.0; 
        gsl_matrix_set (m, i, k, p);
      } }

    // Part 1 for one and zeros
          p=0;  
    for (i=0 ; i<=2; i++) {
      for(k=3; k<=5; k++){
        if ( k-i == 3)
          p= 1.0; 
           else if ( k-i != 6)
           p=0.0;
            gsl_matrix_set (m, i, k, p);
    } }

      //Part 2 for zeros
         p=0.0;
    for (i=3 ; i<=5; i++) {
      for( k=3; k<=5; k++){
            gsl_matrix_set (m, i, k, p);
      } }


  gsl_matrix_set (m, 3, 0, xh_I);
  gsl_matrix_set (m, 3, 1, xh_yi);
  gsl_matrix_set (m, 3, 2, xh_zi);

  gsl_matrix_set (m, 4, 0, xh_xj);
  gsl_matrix_set (m, 4, 1, xh_J);
  gsl_matrix_set (m, 4, 2, xh_zj);

  gsl_matrix_set (m, 5, 0, xh_xk);
  gsl_matrix_set (m, 5, 1, xh_yk);
  gsl_matrix_set (m, 5, 2, xh_K);


// set explicit t dependence of f[i] 
  dfdt[0] = 0.0;
  dfdt[1] = 0.0;
  dfdt[2] = 0.0;
  dfdt[3] = 0.0;
  dfdt[4] = 0.0;
  dfdt[5] = 0.0;  
  return GSL_SUCCESS;
    }

int main (void) 
    {
    double abserr = 1e-14;
    double relerr = 1e-16;
   // double a, b, c, aa, bb, cc;
    double xh[6], xl[6], k_h, k_l;
    // split the numbers as pairs
     pairs(xh, xl) ;
     data *par;
     par=(data *)malloc(sizeof(data));
     k_h=0.017202098950000001276;
     k_l=-0.000000000000000001276;
     Mult(k_h, k_l, k_h, k_l, &par->mu_h, &par->mu_l); 
        gsl_odeiv2_system sys = {func, jac, 12, par};

          // time step parameters 
double t = 0.0, t_step=1, TT=2000;

    // Select explicit method
     const gsl_odeiv2_step_type * T = gsl_odeiv2_step_msadams;
    

    //set errors and create the driver object
    gsl_odeiv2_driver* driver= 
         gsl_odeiv2_driver_alloc_y_new(&sys, T, t_step, abserr, relerr); 
             // set the values inside y[]
    double y[12] = { xh[0], xh[1], xh[2], xl[0], xl[1], xl[2], xh[3], xh[4], xh[5], xl[3], xl[4], xl[5]};

    FILE *kk, *pp;
    kk=fopen("ACC_Rh_Rl.txt","w");
    pp=fopen("ACC_Vh_Vl.txt","w"); 

    // comparison of initial time moment with ordinary
     //printf("%.22le %.22le %.22le %.22le %.22le %.22le\n", y[0], y[1],  y[2], y[3],  y[4], y[5] ); 
    // printf("-6.685074817026049E-01, 1.706558853671706E+00, -1.123043465687632E+00, -1.207950275095047E-02, -3.384553498022686E-03, 3.350958555890135E-03 \n");
                
        while (t <= TT) {
            gsl_odeiv2_driver_apply (driver, &t, t+t_step, y); 

    fprintf(kk,"%f  %.16le %.16le %.16le %.16le %.16le %.16le \n", t, y[0], y[1],  y[2], y[3],  y[4], y[5]);
    fprintf(pp,"%f  %.16le %.16le %.16le %.16le %.16le %.16le \n", t, y[6], y[7], y[8],  y[9], y[10], y[11]);

    // printf ("%.16le %.16le %.16le %.16le %.16le %.16le %.16le\n", t,  y[0], y[1],  y[2], y[3],  y[4], y[5]);
    printf ("%.16le \n",t);
            }
            
            gsl_odeiv2_driver_free (driver);
    fclose(kk);
    fclose(pp);
    return 0;
    //gcc -Wall -I/usr/local/Cellar/gsl/2.6/include gsl_test_accurate.c  -L/usr/local/Cellar/gsl/2.6/lib -lgsl -lgslcblas -lm -o gsl_test_accurate 
    }   
